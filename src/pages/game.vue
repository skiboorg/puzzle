<template>
  <q-page style="overflow: hidden" class="bg-main ">
    <div v-if="game_type==='puzzle'">

      <div v-if="gameType" class="flex  items-center justify-between q-mt-md q-px-lg">

        <q-btn class="text-mira" icon="west" unelevated outline label="back" @click="resetGame"/>
        <div v-if="gameReady && gameType" class=" text-h5 text-weight-regular text-uppercase q-px-lg timer">
          <svg class="q-mr-sm" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M17.6176 5.968L19.0706 4.515L20.4846 5.929L19.0316 7.382C20.4673 9.17917 21.1605 11.4579 20.9687 13.7501C20.7768 16.0424 19.7146 18.1742 18.0001 19.7077C16.2856 21.2412 14.0489 22.0601 11.7496 21.9961C9.45018 21.9321 7.26258 20.9901 5.63604 19.3635C4.00951 17.737 3.0675 15.5494 3.00349 13.25C2.93948 10.9506 3.75832 8.71402 5.29185 6.99951C6.82538 5.285 8.95718 4.22275 11.2494 4.03092C13.5417 3.83909 15.8204 4.53223 17.6176 5.968ZM11.9996 20C12.9188 20 13.8291 19.8189 14.6784 19.4672C15.5276 19.1154 16.2993 18.5998 16.9493 17.9497C17.5993 17.2997 18.1149 16.5281 18.4667 15.6788C18.8185 14.8295 18.9996 13.9193 18.9996 13C18.9996 12.0807 18.8185 11.1705 18.4667 10.3212C18.1149 9.47194 17.5993 8.70026 16.9493 8.05025C16.2993 7.40024 15.5276 6.88463 14.6784 6.53284C13.8291 6.18106 12.9188 6 11.9996 6C10.1431 6 8.36258 6.7375 7.04982 8.05025C5.73707 9.36301 4.99957 11.1435 4.99957 13C4.99957 14.8565 5.73707 16.637 7.04982 17.9497C8.36258 19.2625 10.1431 20 11.9996 20ZM10.9996 8H12.9996V14H10.9996V8ZM7.99957 1H15.9996V3H7.99957V1Z" fill="#0F1549"/>
          </svg>
          <p id="timer" class="q-mb-none">00:00</p></div>
        <div v-else></div>


      </div>
      <div v-else class="q-mt-sm"></div>
      <div style="height: 60vh" v-if="!gameType && !gameReady" >
        <h1 class="text-h4  text-weight-bold text-vela q-pt-lg q-pl-xl q-mb-xl">Tasks</h1>
        <div class="container-inner ">
          <p  class="text-bold text-h5  q-mb-lg text-center" >Choose a game</p>
          <div class="box q-mb-lg">
            <p class="text-caption text-bold q-mb-none">You have 5 tasks left for today</p>
            <div class="flex items-center justify-between">
              <p class="q-mb-none  text-bold"><span class="text-lime">5</span> / 10</p>
              <q-linear-progress style="flex-basis: 85%" :value="0.4" color="lime-13"  />
              <q-btn unelevated class="tooltip">
                <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <rect width="40" height="40" rx="5" fill="#2B1861"/>
                  <path d="M20 30C25.5228 30 30 25.5228 30 20C30 14.4772 25.5228 10 20 10C14.4772 10 10 14.4772 10 20C10 25.5228 14.4772 30 20 30Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M17.0898 17.0006C17.3249 16.3322 17.789 15.7687 18.3998 15.4097C19.0106 15.0507 19.7287 14.9195 20.427 15.0393C21.1253 15.1591 21.7587 15.5221 22.2149 16.0641C22.6712 16.6061 22.9209 17.2921 22.9198 18.0006C22.9198 20.0006 19.9198 21.0006 19.9198 21.0006" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M20 25H20.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>

                <q-tooltip >
                  Some text as content of Tooltip
                </q-tooltip>
              </q-btn>
            </div>

          </div>
          <!--      $user.loggedIn-->
          <div v-if="false" class="">
            <p v-if="can_play" class="text-bold text-body1 text-center text-grey-9 text-uppercase q-mb-md">
              {{$t('you_have')}} {{$user.user.games_count}} {{$t('games_today')}}</p>
            <p v-else class="text-bold text-h5text-uppercase q-mb-md text-center">{{$t('game_limit')}}</p>
            <p style="max-width: 800px; margin: 0 auto 20px" class="text-grey-6 text-center">{{$t('we_give')}}</p>
          </div>
          <div v-if="can_play" class="game-grid">
            <div @click="selectGame(type)" class="game-type cursor-pointer"
                 v-for="type in gameTypes" :key="type.id">
              <img :src="type.img" alt="">
              <p class="text-mira game-type__name q-mb-none">{{type.name}}</p>
              <p class="text-mira game-type__price q-mb-none">0.1 – 0.3 SOL</p>
            </div>
          </div>
        </div>

      </div>
      <div style="height: 90vh" v-if="gameType && !gameReady" class="flex column items-center justify-center ">
        <p class="text-bold text-h4 text-uppercase q-mb-md">{{$t('choose_difficult')}}</p>
        <div class="flex items-center justify-center full-width">
          <q-card
            flat
            @click="startGame(index)"
            class="q-mr-sm cursor-pointer game-level q-pa-lg q-mb-sm"
            v-for="(level,index) in levels"
            :key="level.id"
            :style="{'background-image': 'url('+ level.image +' )'}">
            <q-card-section class="no-padding full-height">
              <div class="flex column items-center justify-evenly full-height">
                <p class="no-margin text-uppercase text-white"><span class="text-weight-medium">{{$t('level')}}:</span> {{level.name}}</p>
                <p class="no-margin text-uppercase text-white"><span class="text-weight-medium">{{$t('pieces')}}:</span> {{level.pieces}}</p>
                <p class="no-margin text-uppercase text-white"><span class="text-weight-medium">{{$t('rating')}}:</span> +{{level.rating}}</p>
                <p class="no-margin text-uppercase text-white"><span class="text-weight-medium">{{$t('timer')}}:</span> {{level.timer}} {{$t('minutes')}}</p>
              </div>
            </q-card-section>
          </q-card>
        </div>
      </div>
      <div style="position: absolute" id="puzzle_wrapper" class=" full-width ">
        <div id="forPuzzle" class=" "></div>
      </div>
    </div>
    <div v-else>
      <div  class="flex column items-center justify-center q-mt-sm">
        <div v-if="sliderStart" class="text-bold text-h5 text-uppercase q-px-lg" id="timer_slider">00:00</div>
        <div v-else></div>
        <p class="no-margin text-bold text-caption text-uppercase cursor-pointer" @click="resetGame">back to games</p>
        <p v-if="sliderStart" class="no-margin text-bold text-caption text-uppercase ">+10 {{$t('rating_title')}}</p>
      </div>
      <div class="slider-area mb-50">
        <div class="slider-container">
          <puzzle-board v-if="show"
                        :autoResize="autoResize"
                        :showNumber="showNumber"
                        :cols="dimensions.x"
                        :rows="dimensions.y"
                        :src="src"

                        :animation="animation"
                        :width="width"
                        :height="height"
                        @init="onPuzzleBoardInit"
                        @start="onPuzzleBoardStart"
                        @change="onPuzzleBoardChange"
                        @finish="onPuzzleBoardFinish"
          />
        </div>
      </div>
    </div>
    <q-dialog v-model="showAd"
              persistent
              transition-show="scale"
              transition-hide="scale"
              @before-show="getAd"
              @before-hide="closeAd">
      <q-card class="adModal" style="width: 380px; max-width: 80vw;">
        <q-card-section class="row items-center q-pb-none relative-position">
          <div v-if="gameWin" class="text-h4 text-bold text-dark  text-center full-width">Cheers! You win</div>
          <div v-else class="text-h4 text-bold text-red  text-center full-width">Try Again!</div>
          <q-space/>
          <q-btn v-if="showClose" icon="close" flat round dense color="dark" v-close-popup class="absolute-top-right" />

        </q-card-section>
        <q-card-section>
          <p v-if="$user.loggedIn" style="max-width: 350px;margin: 0 auto 20px" class="text-center text-dark text-body1">
            If you close this window before you look<br>
            ads - <span class="text-bold">we will subtract your rating<br> for the game</span></p>
          <div v-if="!showClose" style="max-width: 155px;margin: 0 auto; padding: 10px" class="box ">
             <div  id="time_to_close" class="text-weight-bold text-white flex justify-center items-center">
               <svg class="q-mr-sm" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 22C6.477 22 2 17.523 2 12C2 6.477 6.477 2 12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22ZM13 12V7H11V14H17V12H13Z" fill="white"/>
</svg>

               <p class="no-margin " style="letter-spacing: 0.04em">
                 <span class="text-mira text-h6">{{counter | correct_seconds}} </span> sec
               </p>

             </div>
          </div>

          <div v-show="currentAd.image" class="">
            <q-img :src="currentAd.image"/>
          </div>
          <div v-show="currentAd.video" >
            <video ref="video" width="100%" preload="metadata" loop>
              Your browser does not support HTML video.
            </video>
          </div>
        </q-card-section>
      </q-card>
    </q-dialog>
  </q-page>
</template>
<script>
import PuzzleBoard from 'components/PuzzleBoard.vue';
import { mapActions, mapGetters} from 'vuex'

const DIMENSIONS = {
  Easy: { x: 3, y: 3 },
  Normal: { x: 4, y: 4 },
  Difficult: { x: 5, y: 5 }
}

export default {
  components:{
    PuzzleBoard
  },
  data () {
    return {
      //slider
      src: null,
      show: true,
      gameImg:null,
      videoTitle: 'Cat',
      difficulty: 'Normal',
      distance: null,
      isGoal: false,
      sliderStart: false,
      //gameWin: false,
      autoResize: true,
      width: 300,
      height: 300,
      showNumber: true,
      animation: true,
      //sources: SOURCEPATHS['Cat'].sources,
      //slider
      gameType:null,
      gameReady:false,
      gameId:null,
      game_type:'puzzle',
      gameWin:false,
      is_game_stop:false,
      showAd:false,
      showClose:false,
      counter: 0,
      counterSlideTime: 600,
      counterSlide: 10,
      showCloseInterval:null,
      sliderTimerRef:null,
      currentAd:{image:'',video:''},
      AdVideo:[],
      gameTypes:[
        {id:1,name:'qr puzzle',type:'puzzle_qr',img:'game1.png',is_active:true,is_slider:false},
        {id:2,name:'art puzzle',type:'puzzle_image',img:'game2.png',is_active:true,is_slider:false},
        {id:3,name:'new puzzle',type:'new_puzzle',img:'game3.png',is_active:false,is_slider:true},
      ],
    }
  },

  async mounted() {
    this.fetchLevels()
    // if (this.$user.loggedIn){
    //   await this.$api.get('/api/user/game_count')
    //   await this.getUser()
    // }


  },
  computed:{
    ...mapGetters('game_level',['levels']),
    can_play(){
      return true
      // if (this.$user.loggedIn){
      //   return this.$user.user.games_count > 0
      // }else {
      //   return true
      // }
    },
    dimensions() {
      return DIMENSIONS[this.difficulty]
    }

  },
  filters:{
    correct_seconds(val){
      return val < 10 ? `0${val}` : val
    }
  },

  methods:{
    ...mapActions('game_level',['fetchLevels']),
    ...mapActions('auth',['getUser']),
    //slider
    async onPuzzleBoardInit() {
      this.counterSlide = this.counterSlideTime
      this.$q.loading.show()
      console.log('init')
      const game_info = await this.$api.post('/api/start_game',{level_id:1,type:'puzzle_image'})
      console.log(game_info.data)
      this.gameId = game_info.data.id
      this.src = process.env.API + game_info.data.img
      this.isGoal = false
      this.sliderStart = true
      this.$q.loading.hide()


    },
    onPuzzleBoardStart() {
      console.log('start')

      let that=this
      this.sliderTimerRef = setInterval(async function(){
        that.counterSlide-=1
        if (that.counterSlide === 0){
          console.log('time out')
          clearInterval(that.sliderTimerRef)
          that.gameWin = false
          that.showAd = true
        }
        let minutes = parseInt(that.counterSlide/60);
        let seconds = parseInt(that.counterSlide%60);


        if(minutes < 10)
          minutes = "0"+minutes;

        if(seconds < 10)
          seconds = "0"+seconds;

        document.getElementById('timer_slider').innerText = minutes + ":" + seconds;


      },1000)
    },
    async onPuzzleBoardFinish() {
      console.log('finish')
      clearInterval(this.sliderTimerRef)
      this.gameWin = true
      this.showAd = true
      const response = await this.$api.post('/api/slider_win',{game_id:this.gameId})
      console.log(response.data)
    },
    onPuzzleBoardChange: function(payload) {
      console.log('change')
      this.distance = payload.distance
    },
    //slider
    selectGame(game_type){
      if (game_type.is_slider){
        console.log('slider')
        this.game_type = 'slider'
      }else {
        this.game_type = 'puzzle'
        this.gameType=game_type.type

      }

    },
    async resetGame(){
      //this.$router.go(this.$router.currentRoute)
      if (this.game_type==='slider'){
        this.game_type='puzzle'
        clearInterval(this.sliderTimerRef)
      }else{
        document.getElementById('forPuzzle').innerHTML=''
        this.is_game_stop=true
        this.gameType=null
        this.gameReady=false
        this.gameId=null
        this.gameWin=false
      }


      //   if (this.$user.loggedIn){
      //   await this.$api.get('/api/user/game_count')
      //   await this.getUser()
      // }
    },
    closeAd(){
      clearInterval(this.showCloseInterval)
      this.resetGame()

    },
    async getAd(){
      let that=this
      this.counter=20
      this.showClose=false
      const ad_info = await this.$api.get('/api/ad')
      this.currentAd = ad_info.data
      if(this.currentAd.video){
        try{
          let video_source = document.getElementById('video_source');
          video_source.remove()
        }catch {
          console.log('not')
        }
        let video =  this.$refs.video
        let source = document.createElement('source');
        source.setAttribute('src', this.currentAd.video);
        source.setAttribute('id', 'video_source');
        video.appendChild(source);
        video.play();
      }
      this.showCloseInterval = setInterval(async function(){
        that.counter-=1
        if (that.counter === 0){
          that.showClose = true
          if (that.$user.loggedIn){
            await that.$api.post('/api/end_game',{
              game_id:that.gameId,
              request_type:'add_rating',
              game_status:that.gameWin,
            })
            await that.getUser()
          }
        }
      },1000)
    },
    async startGame(index){
      this.$q.loading.show()
      this.is_game_stop=false
      this.gameReady = true
      //this.createPuzzle('https://millionstatusov.ru/pic/statpic/all8/5e04c21a52a39.jpg',15,3)
      const game_info = await this.$api.post('/api/start_game',{level_id:this.levels[index].id,type:this.gameType})
      console.log(game_info.data)
      this.gameId = game_info.data.id
      this.gameReady = true
      this.createPuzzle(process.env.API+game_info.data.img,this.levels[index].pieces,this.levels[index].timer)
      this.$q.loading.hide()
    },
    winGame(){
      this.gameWin = true
      this.showAd = true
    },
    async looseGame(){
      if (this.$user.loggedIn){
        await this.$api.post('/api/end_game',{
          game_id:this.gameId,
          request_type:'remove_rating',
          game_status:this.gameWin,
        })
        await this.getUser()
      }
      this.showAd = true
      this.is_game_stop=false
    },
    createPuzzle(image,pieces,minutes){
      let totalAmount = 60*minutes;
      let checkTimerInterval;
      let checkGameStopInterval;
      let timeloop = '';
      let mycoeff = this.$q.screen.gt.md ? 0.7 : .9;

      let autoStart;
      let that=this
      let mycoeff1 = 0; //добавил новый коэффициент, по умолчанию он равен нулю

      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) { //если пользователь с телефона
        mycoeff1 = 0.001; //то меняем коэффициент
      }
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
      function arrayShuffle (array) {
        /* randomly changes the order of items in an array
           only the order is modified, not the elements
        */
        let k1, temp;
        for (let k = array.length - 1; k >= 1; --k) {
          k1 = Math.floor((k + 1) * Math.random());
          temp = array[k];
          array[k] = array[k1];
          array[k1] = temp;
        } // for k
        return array
      } // arrayShuffle
      function timeSet() {
        totalAmount--;
        // Refresh value in localStorage
        //localStorage.setItem('countDown', totalAmount);

        // If countdown is over, then remove value from storage and clear timeout
        if (totalAmount < 0 ) {
          //localStorage.removeItem('countDown');
          totalAmount = 0;
          return;
        }

        var minutes = parseInt(totalAmount/60);
        var seconds = parseInt(totalAmount%60);


        if(minutes < 10)
          minutes = "0"+minutes;

        if(seconds < 10)
          seconds = "0"+seconds;

        document.getElementById('timer').innerText = minutes + ":" + seconds;
        timeloop = setTimeout(timeSet, 1000);
      }

// Point - - - - - - - - - - - - - - - - - - - -
      function Point(x,y) {
        this.x = Number(x);
        this.y = Number(y);
      } // Point

      Point.prototype.copy = function() {
        return new Point(this.x,this.y);
      }
// end Point - - - - - - - - - - - - - - - - - - - -

// Segment - - - - - - - - - - - - - - - - - - - -
// those segments are oriented

      function Segment(p1,p2) {
        this.p1=new Point(p1.x,p1.y);
        this.p2=new Point(p2.x,p2.y);
      }

      Segment.prototype.length = function() {
        var dx=this.p1.x-this.p2.x;
        var dy=this.p1.y-this.p2.y;
        return Math.sqrt(dx*dx+dy*dy);
      }
      Segment.prototype.intersect = function(otherSegment) {
// take care of  paralel line segments if they are possible
        var x1=this.p1.x;
        var y1=this.p1.y;
        var x2=this.p2.x;
        var y2=this.p2.y;
        var x3=otherSegment.p1.x;
        var y3=otherSegment.p1.y;
        var x4=otherSegment.p2.x;
        var y4=otherSegment.p2.y;
        var discri=(y2-y1)*(x4-x3)-(x2-x1)*(y4-y3);
        var xs=x1*(y2-y1)*(x4-x3)-x3*(x2-x1)*(y4-y3)+(y3-y1)*(x2-x1)*(x4-x3);
        xs/=discri;

        var ys=y1*(x2-x1)*(y4-y3)-y3*(y2-y1)*(x4-x3)+(x3-x1)*(y2-y1)*(y4-y3);
        ys=-ys/discri;

        return new Point(xs,ys);
      }
      Segment.prototype.dx =function() {
        return this.p2.x-this.p1.x;
      }
      Segment.prototype.dy =function() {
        return this.p2.y-this.p1.y;
      }

      Segment.prototype.cross =function(otherSegment) {
        return (this.dx()*otherSegment.dy()-this.dy()*otherSegment.dx());
      }
      Segment.prototype.sin =function(otherSegment) {
// attention if length can be 0
// angle turning from this towards otherSegment
        return this.cross(otherSegment)/this.length()/otherSegment.length();
      }

      Segment.prototype.dot =function(otherSegment) {
        return (this.dx()*otherSegment.dx()+this.dy()*otherSegment.dy());
      }

      Segment.prototype.cos =function(otherSegment) {
// attention if length can be 0
// angle turning from this towards otherSegment
        return this.dot(otherSegment)/this.length()/otherSegment.length();
      }

// returns a point at a given distance of p1, positive direction beeing towards p2
      Segment.prototype.pointOnAbsolute = function (abscisse) {
// attention if segment length can be 0
        var dx= this.p2.x-this.p1.x;
        var dy= this.p2.y-this.p1.y;
        var lng=Math.sqrt(dx*dx+dy*dy);
        return new Point(this.p1.x+abscisse*dx/lng, this.p1.y+abscisse*dy/lng);
      }

      Segment.prototype.pointOnRelative = function (coeff) {
// attention if segment length can be 0
        var dx= this.p2.x-this.p1.x;
        var dy= this.p2.y-this.p1.y;
        return new Point(this.p1.x+coeff*dx, this.p1.y+coeff*dy);
      }

// returns a segment with origin p1, perpendicular to p1p2
      Segment.prototype.perpendicularOrigin = function (positive) {
        var dx= this.p2.x-this.p1.x;
        var dy= this.p2.y-this.p1.y;
        if (positive) return new Segment(this.p1,new Point(this.p1.x-dy,this.p1.y+dx));
        return new Segment(this.p1,new Point(this.p1.x+dy,this.p1.y-dx));
      }
// returns a segment with origin p2, perpendicular to p1p2
      Segment.prototype.perpendicularEnd = function (positive) {
        var dx= this.p2.x-this.p1.x;
        var dy= this.p2.y-this.p1.y;
        if (positive) return new Segment(this.p2,new Point(this.p2.x-dy,this.p2.y+dx));
        return new Segment(this.p2,new Point(this.p2.x+dy,this.p2.y-dx));
      }

// end Segment
// side of a piece

      function Side() {
        this.type = ""; // "d" pour straight line or "z" pour classic
        this.points = []; // real points or Bezier curve points
      } // Side

      /*
      draws the path corresponding to a side
      Parameters :
        ctx : canvas context
        shiftx, shifty : position shift used to create shadow effect
        backwards : boolean, must be true for bottom and left sides, which must be drawn
            from the last point to the first
        withoutMoveTo : to decide whether to do a moveTo to the first point. Without MoveTo
        must be done only for the first side of a piece, not for the following ones
      */

      Side.prototype.drawPath = function(ctx, shiftx, shifty, backwards, withoutMoveTo) {

        let k, mix, miy;

        if (backwards) {
          if (!withoutMoveTo) {
            ctx.moveTo(this.points[this.points.length - 1].x - shiftx, this.points[this.points.length - 1].y - shifty);
          }
          if(this.type == "d") {
            ctx.lineTo(this.points[0].x - shiftx, this.points[0].y - shifty);
          } else { // jigsaw side
            for (k = this.points.length - 2 ; k>0; k--) {
              if (k >1) {
                mix = (this.points[k].x + this.points[k - 1].x) / 2 - shiftx;
                miy = (this.points[k].y + this.points[k - 1].y) / 2 - shifty;
                ctx.quadraticCurveTo(this.points[k].x - shiftx, this.points[k].y - shifty, mix, miy);
              } else {
                ctx.quadraticCurveTo(this.points[k].x - shiftx, this.points[k].y - shifty, this.points[k - 1].x - shiftx, this.points[k - 1].y - shifty);
              }
            } // for k
          } // if jigsaw side
        } else {
          if (!withoutMoveTo) {
            ctx.moveTo(this.points[0].x - shiftx, this.points[0].y - shifty);
          }
          if(this.type == "d") {
            ctx.lineTo(this.points[1].x - shiftx, this.points[1].y - shifty);
          } else { // edge zigzag
            for (k = 1 ; k < this.points.length - 1; k++) {
              if (k < this.points.length - 2) {
                mix = (this.points[k].x + this.points[k + 1].x) / 2 - shiftx;
                miy = (this.points[k].y + this.points[k + 1].y) / 2 - shifty;
                ctx.quadraticCurveTo(this.points[k].x - shiftx, this.points[k].y - shifty, mix, miy);
              } else {
                ctx.quadraticCurveTo(this.points[k].x - shiftx, this.points[k].y - shifty, this.points[k + 1].x - shiftx, this.points[k + 1].y - shifty);
              }
            } // for k
          } // if jigsaw side
        }
      } // Side.prototype.drawPath

// fin Side
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      function Piece(kx, ky) { // object with 4 sides
        this.ts = new Side(); // top side
        this.rs = new Side(); // right side
        this.bs = new Side(); // bottom side
        this.ls = new Side(); // left side
        this.kx = kx;
        this.ky = ky;
      }

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      /* draw path for one piece
        shiftx and shifty used for shadow effect
        does from beginPath to closePath, but not actually draw : no stroke nor fill nor clip here
      */

      Piece.prototype.drawPath = function (ctx, shiftx, shifty, withoutBeginPath) {

        if (withoutBeginPath !== true) ctx.beginPath();

        this.ts.drawPath(ctx, shiftx, shifty, false, false); // top side
        this.rs.drawPath(ctx, shiftx, shifty, false, true);  // right side
        this.bs.drawPath(ctx, shiftx, shifty, true, true);   // bottom side
        this.ls.drawPath(ctx, shiftx, shifty, true, true);   // left

      } //

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      /*
      creates and returns a div for an individual piece, with a canvas with shadow, and a part of the picture
      canvas and div are three times the average size of pieces
      puzzle object given in parameters provides required elements
      scale and x and y offsets allow to scale and truncate picture to actual size
      */
// crée et rend un div pour pièce individuelle, avec un canvas avec ombre et extrait de l'image
// le canvas et le div font trois fois la width et la height moyennes des pièces
// l'objet puzzle donné en entrée donne les éléments nécessaires
// l'échelle et les offsets x et y permettent de mettre à l'échelle et tronquer l'image réelle pour l'adapter au plateau

      Piece.prototype.createDivPiece = function(puzzle, scale, offsx, offsy) {

        let ctx, shiftx, shifty;
        this.theDiv = document.createElement('div');
        this.theDiv.style.width = 3 * puzzle.dx + "px";
        this.theDiv.style.height = 3 * puzzle.dy + "px";
        this.theDiv.style.position = "absolute";

        this.theCanv = document.createElement('canvas');
        this.theCanv.width = 3 * puzzle.dx;
        this.theCanv.height = 3 * puzzle.dy;

// origine shifting for path drawing
        shiftx = puzzle.dx * (this.kx - 1);
        shifty = puzzle.dy * (this.ky - 1);

        ctx = this.ctx = this.theCanv.getContext("2d");
        this.drawPath(ctx, shiftx, shifty);

        ctx.clip();

        ctx.drawImage(puzzle.image, (this.kx - 1) * puzzle.dx / scale + offsx,
          (this.ky - 1 ) * puzzle.dy / scale + offsy,
          3 * puzzle.dx / scale, 3 * puzzle.dy / scale,
          0, 0,
          3 * puzzle.dx, 3 * puzzle.dy);
// shadow effect
// depends on size of pieces

        let shift = 1, thickness = 2;
        if (puzzle.dx > 100 && puzzle.dy > 100) {
          shift = 2; thickness = 5;
        } else if (puzzle.dx > 50 && puzzle.dy > 50) {
          shift = 1.5; thickness = 3;
        }

        this.drawPath(ctx, shiftx + shift, shifty + shift);
        ctx.lineWidth = thickness;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
        ctx.stroke();
        this.drawPath(ctx, shiftx - shift, shifty - shift);
        ctx.lineWidth = thickness;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.stroke();
        this.drawPath(ctx, shiftx, shifty); // path used for selection of the piece

        /* place of the piece at the beginning of the game */
        this.moveTo(new Point((this.kx - 1) * puzzle.dx + Puzzle.MARGIN1,
          (this.ky - 1) * puzzle.dy + Puzzle.MARGIN1));

        this.theDiv.appendChild(this.theCanv);

        return this.theDiv;
      } // createDivPiece
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

// returns position of current piece

      Piece.prototype.where = function() {
        let x, y;
        x = parseFloat(this.theDiv.style.left);
        y = parseFloat(this.theDiv.style.top);
        return new Point(x, y);
      } // Piece.prototype.where

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      /* move piece to a given location
      onePoint if location of top lefthand corner of div (far beyond visible par of piece)
      */
      Piece.prototype.moveTo = function(onePoint) {
        this.theDiv.style.top = onePoint.y + "px";
        this.theDiv.style.left = onePoint.x + "px";
      } // Piece.prototype.moveTo

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// true if given (mouse) coordoninates are inside the piece

      Piece.prototype.insidePiece = function(x, y) {

        let styl = getComputedStyle(this.theDiv);
        let xloc = x - parseFloat(styl.left); // 'local' x and y
        let yloc = y - parseFloat(styl.top);

        return this.ctx.isPointInPath(xloc, yloc);

      } // Piece.prototype.insidePiece

// fin Piece


//--------------------------------------------------------------
//--------------------------------------------------------------
// class PolyPiece
// represents a group de pieces well positionned with respect  to each other.
// pckxmin, pckxmax, pckymin and pckymax record each a piece with highest kx, lowest kx...


      function PolyPiece(initialPiece, puzz) {
        this.pckxmin  =
          this.pckxmax  =
            this.pckymin  =
              this.pckymax = initialPiece;
        this.pieces = [initialPiece];
        this.puzzle = puzz;
      } // PolyPiece

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      /*
        this method
          - adds pieces of otherPoly to this PolyPiece
          - adjusts coordinates of new pieces to make the consistent with this polyPiece
          - does not re - evaluate the z - index of the polyPieces
      */

      PolyPiece.prototype.merge = function(otherPoly) {

        for (let k = 0; k < otherPoly.pieces.length; ++k) {
          this.pieces.push(otherPoly.pieces[k]);
          // watch leftmost, topmost... pieces
          if (otherPoly.pieces[k].kx < this.pckxmin.kx) this.pckxmin = otherPoly.pieces[k];
          if (otherPoly.pieces[k].kx > this.pckxmax.kx) this.pckxmax = otherPoly.pieces[k];
          if (otherPoly.pieces[k].ky < this.pckymin.ky) this.pckymin = otherPoly.pieces[k];
          if (otherPoly.pieces[k].ky > this.pckymax.ky) this.pckymax = otherPoly.pieces[k];
        } // for k

        this.moveTo(this.where()); // to set positions of new pieces

// sort the pièces by increasing kx, ky

        this.pieces.sort(function(p1, p2){
          if (p1.ky < p2.ky) return  - 1;
          if (p1.ky > p2.ky) return 1;
          if (p1.kx < p2.kx) return  - 1;
          if (p1.kx > p2.kx) return 1;
          return 0; // should not occur
        });

      } // merge

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      PolyPiece.prototype.where = function() {
        return this.pieces[0].where();
      } // PolyPiece.prototype.where

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// the position of the PolyPiece is this of its 1st piece
// the position of the others is evaluated on this basis

      PolyPiece.prototype.moveTo = function(pnt) {

        this.pieces[0].moveTo(pnt);
        for (let kp = 1; kp < this.pieces.length; ++kp) {
          this.pieces[kp].moveTo(new Point(pnt.x + this.puzzle.dx * (this.pieces[kp].kx - this.pieces[0].kx ),
            pnt.y + this.puzzle.dy * (this.pieces[kp].ky - this.pieces[0].ky )));
        } // for kp
      } // PolyPiece.prototype.moveTo

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      PolyPiece.prototype.ifNear = function(otherPoly) {

        let p1, p2;
        for (let kp = 0; kp < this.pieces.length; ++kp) {
          p1 = this.pieces[kp];
          for (let kn = 0; kn < otherPoly.pieces.length; ++kn) {
            p2 = otherPoly.pieces[kn];
// p2 above p1 ?
            if ((p1.kx == p2.kx && p1.ky == p2.ky + 1) &&
              (this.puzzle.near(p1, p2, 0, - 1))) return true;
// p2 below p1 ?
            if ((p1.kx == p2.kx && p1.ky == p2.ky - 1) &&
              (this.puzzle.near(p1, p2, 0, 1))) return true;
// p2 left of p1 ?
            if ((p1.kx - 1 == p2.kx && p1.ky == p2.ky) &&
              (this.puzzle.near(p1, p2, - 1, 0))) return true;
// p2 right of p1 ?
            if ((p1.kx + 1 == p2.kx && p1.ky == p2.ky) &&
              (this.puzzle.near(p1, p2, + 1, 0))) return true;
          } // for kn
        } // for kp
        return false; // no, not near
      } // ifNear

// end class PolyPiece
//--------------------------------------------------------------
//--------------------------------------------------------------
// puzzle

      /* see createPuzzle for the 'params' parameter
      This constructor is used to load the picture, the actual construction of the
      puzzle can't be done before picture dimensions are known
      */

      function Puzzle(params) {

// image - by url (src) or straight image object
        if (typeof(params.img) == 'string') {
          this.image = new Image();
          this.image.src = params.img;
          this.image.addEventListener("load", (function(obj){
            return function() {
              obj.createPuzzle(params);
            }})(this));
        } else {
          this.image = params.img;
          this.createPuzzle(params);
        }

      } // Puzzle

      Puzzle.MARGIN1 = 5;
//--------------------------------------------------------------

      /*
      The given parameter if an object with the following properties :
       -  img, which may be:
        string type : an image url
        object type : an image object (with a ready loaded image)
       -  width : width available for the picture
       -  height : width available for the picture. The script will use the
      width x height space as smartly as possible
       -  npieces : number of pieces. May be any (sensible) integer, the script
      will choose a number of columns and rows to have pieces as square as possible,
      and an actual total number of pieces as close as possible to this integer.
       -  idiv : div which will contail the game

      */

      Puzzle.prototype.createPuzzle = function(params){

//  let kx, ky, x, y, dx, dy, p1, p2, p3, brd, s1, s2, s3, s4, s5, s6, s7, s8, s9, concav, width, height, nx, ny;

// we change width or height in order to keep the picture size ration
        let wi = this.image.width;  // from original picture
        let he = this.image.height;

        this.reqHeight = params.height * (mycoeff + mycoeff1);// requested height
        this.reqWidth = params.width * mycoeff;
        this.height = this.reqHeight - 2 * Puzzle.MARGIN1; // place left on screen including margin
        this.width = this.reqWidth - 2 * Puzzle.MARGIN1; //

        if ((wi / he) * mycoeff > this.width / this.height) { // actual picture "more horizontal" than game board
          this.height = this.width * he / wi;
        } else {
          this.width = this.height * wi / he;
        }
// end change width or height


// div Jeu - par nom (id) where directement objet
        if (typeof(params.idiv) == 'string') {
          this.divGame = document.getElementById(params.idiv);
        } else {
          this.divGame = params.idiv;
        }
        this.divGame.style.overflow = 'visible';
        this.divGame.style.position = 'relative';

// divBoard
        if (!this.divBoard) {
          this.divBoard = document.createElement('div');
          this.divGame.appendChild(this.divBoard);
        }
        this.divBoard.style.overflow = 'hidden';
        this.divBoard.style.position = 'absolute';
        this.divBoard.style.left = 0;
        this.divBoard.style.top = 0;

        this.listeners = []; // table of eventListeners to remove

        /* provisional dimensions of the game, waiting for actual dimensions qui depend
        on number of pieces
        */

        this.divGame.style.width = this.divBoard.style.width = this.width + 2 * Puzzle.MARGIN1 + "px";
        this.divGame.style.height = this.divBoard.style.height = this.height + 2 * Puzzle.MARGIN1 + "px";

// canv for the moving PolyPiece and the full image
        if (!this.canvMobile) {
          this.canvMobile = document.createElement('canvas');
          this.divBoard.appendChild(this.canvMobile);
        }
        this.canvMobile.style.visibility = 'visible';
        this.canvMobile.width = parseFloat(this.divBoard.style.width);
        this.canvMobile.height = parseFloat(this.divBoard.style.height);
        this.canvMobile.style.position = "absolute";
        this.canvMobile.style.top = "0px";
        this.canvMobile.style.left = "0px";

        this.canvMobile.style.zIndex = 50000;

        this.dCoupling = 10; // distance for pieces to couple together, in pixels (on each x and y axis)

        this.canvMobile.getContext("2d").drawImage(this.image,
          0, 0, wi, he,
          Puzzle.MARGIN1, Puzzle.MARGIN1, this.width, this.height);



        this.npieces = pieces;
        this.next();

      } // createPuzzle
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// function for menu actions

      Puzzle.prototype.returnFunct = function(nbpieces) {

        let puz = this;
        return function() {
          puz.npieces = nbpieces;
          puz.next();
        }
      } // returnFunct

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.loadImage = function () {

        let puz = this;
        return function() {
          uploadFile(() => {},
            {accept: 'image/*',
              readMethod: 'readAsDataURL',
              image: puz.image});
        }
      }

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.next = function() {

        let nx, ny, dx, dy, kx, ky, x, y, p1, p2, p3, brd, s1, s2, s3, s4, s5, s6, s7, s8, s9, concav;
        /* parameters for the shape of pieces edges
         despite of careful tweaking, I never got the shape I expected
        */

        let coeffDecentr = 0.15;
        let coeff1min = 0.8;
        let coeff1max = 0.9;
        let coeff2min = 0.1;
        let coeff2max = 0.15;
        let coeff3min = 0.05;
        let coeff3max = 0.1;
        let coeff4min = 0.15;
        let coeff4max = 0.2;

        this.canvMobile.style.visibility = 'hidden'; // hide the full picture

// evaluation of number of pieces

        this.computenxAndny();
        nx = this.nx;  ny = this.ny;

// re - evaluation of the dimensions of the picture, leaving a space for pieces on one side

        if (this.image.width / this.image.height <
          (this.reqWidth - 2 * Puzzle.MARGIN1) / (this.reqHeight - 2 * Puzzle.MARGIN1)) {
          /* actual picture "more vertical" than available place
            leave place on the right side */
          this.width = (this.reqWidth - 2 * Puzzle.MARGIN1) / (nx + 2) * nx;
          this.height = this.width / this.image.width * this.image.height;
          if (this.height > this.reqHeight - 2 * Puzzle.MARGIN1) {
            this.height = this.reqHeight - 2 * Puzzle.MARGIN1;
            this.width = this.height * this.image.width / this.image.height;
          }
          this.freeSpace = 0; // place left on the right
        } else {
          /* actual picture "more horizontal" than available place
              leave place on the bottom side */
          this.height = (this.reqHeight - 2 * Puzzle.MARGIN1) / (ny + 2) * ny;
          this.width = this.height / this.image.height * this.image.width;
          if (this.width > this.reqWidth - 2 * Puzzle.MARGIN1) {
            this.width = this.reqWidth - 2 * Puzzle.MARGIN1;
            this.height = this.width * this.image.height / this.image.width;
          }
          this.freeSpace = 1; // place left under
        }

        let height = this.height, width = this.width;
        this.dx = dx = this.width / nx; // horizontal side of tiling
        this.dy = dy = this.height / ny; // vertical side of tiling

        /* adjust coupling distance to size of tiles */
        this.dCoupling = Math.max(10, Math.min(dx, dy) / 10);

// "clean" the board
        while (this.divBoard.firstChild) this.divBoard.removeChild(this.divBoard.firstChild);
// but keep the canvMobile
        this.divBoard.appendChild(this.canvMobile);

        this.canvMobile.width = this.reqWidth * 1/mycoeff - 4 * Puzzle.MARGIN1; //здесь прибавляем для увеличения игровой ширины ПОМЕТКА, я добавил * 1/mycoeff
        this.divGame.style.width
          = this.divBoard.style.width
          = this.canvMobile.width + "px";

        this.canvMobile.height = this.reqHeight * 1/(mycoeff + mycoeff1) - 4 * Puzzle.MARGIN1; //здесь прибавляем для увеличения игровой длины ПОМЕТКА, я добавил * 1/mycoeff
        this.divGame.style.height
          = this.divBoard.style.height
          = this.canvMobile.height + "px";

// compute the shapes of the pieces

        let lSide = [];
        let rSide = [];
        for (ky = 0; ky <=  ny; ++ky) {
          if (ky == 0) y = 0; else if (ky == ny) y = height; else y = (ky + (2 * Math.random() - 1) * coeffDecentr) * dy;
          lSide[ky] = new Point(0, y);
          if (ky == 0) y = 0; else if (ky == ny) y = height; else y = (ky + (2 * Math.random() - 1) * coeffDecentr) * dy;
          rSide[ky] = new Point(this.width, y);
        } // compute left and right side

        let tSide = [];
        let bSide = [];
        for (kx = 0; kx <=  nx; ++kx) {
          if (kx == 0) x = 0; else if (kx == nx) x = width; else x = (kx + (2 * Math.random() - 1) * coeffDecentr) * dx;
          tSide[kx] = new Point(x, 0);
          if (kx == 0) x = 0; else if (kx == nx) x = width; else x = (kx + (2 * Math.random() - 1) * coeffDecentr) * dx;
          bSide[kx] = new Point(x, this.height);
        } // compute top and bottom sides

// vertices along horizontal axis
        let verticesH = [];
        for (ky = 0; ky < ny - 1; ++ky) {
          verticesH[ky] = [];
          for (kx = 0; kx < nx; ++kx) {
            x = (kx + 0.5 + (2 * Math.random() - 1) * coeffDecentr / 2) * dx;
            y = (ky + 1 + (2 * Math.random() - 1) * coeffDecentr) * dy;
            verticesH[ky][kx] = new Point(x, y);
          } // for kx
        } // for ky

// vertices along vertical axis
        let verticesV = [];
        for (kx = 0; kx < nx - 1; ++kx) {
          verticesV[kx] = [];
          for (ky = 0; ky < ny; ++ky) {
            y = (ky + 0.5 + (2 * Math.random() - 1) * coeffDecentr / 2) * dy;
            x = (kx + 1 + (2 * Math.random() - 1) * coeffDecentr) * dx;
            verticesV[kx][ky] = new Point(x, y);
          } // for kx
        } // for ky

// intersections of segments
// [ky][kx] containst teh coordinate of the bottom right corner of a cell
        let tbIntersect = [];
        for (ky = 0; ky < ny - 1; ++ky) {
          tbIntersect[ky] = [];
          for (kx = 0; kx < nx - 1; ++kx) {
            tbIntersect[ky][kx] = new Segment(verticesV[kx][ky], verticesV[kx][ky + 1])
              .intersect(new Segment(verticesH[ky][kx], verticesH[ky][kx + 1]));
          } // for kx
        } // for ky

// Array of pieces
        this.pieces = [];
        for (ky = 0; ky < ny; ++ky) {
          this.pieces[ky] = [];
          for (kx = 0; kx < nx; ++kx) {
            this.pieces[ky][kx] = new Piece(kx, ky);

            // upper side
            if (ky == 0) {
              this.pieces[ky][kx].ts.type = "d";
              this.pieces[ky][kx].ts.points = [tSide[kx].copy(), tSide[kx + 1].copy()];
            } else {
              this.pieces[ky][kx].ts.type = "z";
              if (kx == 0) p1 = lSide[ky]; else p1 = tbIntersect[ky - 1][kx - 1];
              p2 = verticesH[ky - 1][kx];
              if (kx == nx - 1) p3 = rSide[ky]; else p3 = tbIntersect[ky - 1][kx];
              this.pieces[ky][kx].ts.points = [p1.copy(), p2.copy(), p3.copy()];
            }
            // right side
            if (kx == nx - 1) {
              this.pieces[ky][kx].rs.type = "d";
              this.pieces[ky][kx].rs.points = [rSide[ky].copy(), rSide[ky + 1].copy()];
            } else {
              this.pieces[ky][kx].rs.type = "z";
              if (ky == 0) p1 = tSide[kx + 1]; else p1 = tbIntersect[ky - 1][kx];
              p2 = verticesV[kx][ky];
              if (ky == ny - 1) p3 = bSide[kx + 1]; else p3 = tbIntersect[ky][kx];
              this.pieces[ky][kx].rs.points = [p1.copy(), p2.copy(), p3.copy()];
            }
            // bottom side
            if (ky == ny - 1) {
              this.pieces[ky][kx].bs.type = "d";
              this.pieces[ky][kx].bs.points = [bSide[kx].copy(), bSide[kx + 1].copy()];
            } else {
              this.pieces[ky][kx].bs.type = "z";
              if (kx == 0) p1 = lSide[ky + 1]; else p1 = tbIntersect[ky][kx - 1];
              p2 = verticesH[ky][kx];
              if (kx == nx - 1) p3 = rSide[ky + 1]; else p3 = tbIntersect[ky][kx];
              this.pieces[ky][kx].bs.points = [p1.copy(), p2.copy(), p3.copy()];
            }
            // left side
            if (kx == 0) {
              this.pieces[ky][kx].ls.type = "d";
              this.pieces[ky][kx].ls.points = [lSide[ky].copy(), lSide[ky + 1].copy()];
            } else {
              this.pieces[ky][kx].ls.type = "z";
              if (ky == 0) p1 = tSide[kx]; else p1 = tbIntersect[ky - 1][kx - 1];
              p2 = verticesV[kx - 1][ky];
              if (ky == ny - 1) p3 = bSide[kx]; else p3 = tbIntersect[ky][kx - 1];
              this.pieces[ky][kx].ls.points = [p1.copy(), p2.copy(), p3.copy()];
            }
          } // for kx
        } // for ky

// transformation of sides
        for (ky = 0; ky < ny; ky++) {
          for (kx = 0; kx < nx; kx++) {

// bottom side
            if (ky < ny - 1) {
              brd = this.pieces[ky][kx].bs;
              s1 = new Segment(brd.points[0], brd.points[1]);
              s2 = new Segment(brd.points[2], brd.points[1]);
              concav = (s1.sin(s2) > 0);
              s1 = new Segment(s1.p1, s1.pointOnRelative(Math.random() * (coeff1max - coeff1min) + coeff1min));
              s3 = s1.perpendicularEnd(!concav);
              s3 = new Segment(s3.p1, s3.pointOnAbsolute(dy * (Math.random() * (coeff2max - coeff2min) + coeff2min)));
              s2 = new Segment(s2.p1, s2.pointOnRelative(Math.random() * (coeff1max - coeff1min) + coeff1min));
              s4 = s2.perpendicularEnd(concav);
              s4 = new Segment(s4.p1, s4.pointOnAbsolute(dy * (Math.random() * (coeff2max - coeff2min) + coeff2min)));
              s5 = new Segment(s3.p2, s4.p2);
              s6 = new Segment(s5.p1, s5.pointOnAbsolute( -dx * (Math.random() * (coeff3max - coeff3min) + coeff3min)));
              s5 = new Segment(s5.p2, s5.p1);
              s7 = new Segment(s5.p1, s5.pointOnAbsolute( -dx * (Math.random() * (coeff3max - coeff3min) + coeff3min)));
              s8 = s6.perpendicularEnd(concav);
              s8 = new Segment(s8.p1, s8.pointOnAbsolute(dy * (Math.random() * (coeff4max - coeff4min) + coeff4min)));
              s9 = s7.perpendicularEnd(!concav);
              s9 = new Segment(s9.p1, s9.pointOnAbsolute(dy * (Math.random() * (coeff4max - coeff4min) + coeff4min)));

              brd.points[0] = s1.p1.copy();
              brd.points[1] = s1.p2.copy();
              brd.points[2] = s3.p2.copy();
              brd.points[3] = s6.p2.copy();
              brd.points[4] = s8.p2.copy();
              brd.points[5] = s9.p2.copy();
              brd.points[6] = s7.p2.copy();
              brd.points[7] = s4.p2.copy();
              brd.points[8] = s2.p2.copy();
              brd.points[9] = s2.p1.copy();
              // duplicate as top side of cell below
              this.pieces[ky + 1][kx].ts = brd;
            } // end bottom side

// right side
            if (kx < nx - 1) {
              brd = this.pieces[ky][kx].rs;
              s1 = new Segment(brd.points[0], brd.points[1]);
              s2 = new Segment(brd.points[2], brd.points[1]);
              concav = (s1.sin(s2) > 0);
              s1 = new Segment(s1.p1, s1.pointOnRelative(Math.random() * (coeff1max - coeff1min) + coeff1min));
              s3 = s1.perpendicularEnd(!concav);
              s3 = new Segment(s3.p1, s3.pointOnAbsolute(dx * (Math.random() * (coeff2max - coeff2min) + coeff2min)));
              s2 = new Segment(s2.p1, s2.pointOnRelative(Math.random() * (coeff1max - coeff1min) + coeff1min));
              s4 = s2.perpendicularEnd(concav);
              s4 = new Segment(s4.p1, s4.pointOnAbsolute(dx * (Math.random() * (coeff2max - coeff2min) + coeff2min)));
              s5 = new Segment(s3.p2, s4.p2);
              s6 = new Segment(s5.p1, s5.pointOnAbsolute( - dy * (Math.random() * (coeff3max - coeff3min) + coeff3min)));
              s5 = new Segment(s5.p2, s5.p1);
              s7 = new Segment(s5.p1, s5.pointOnAbsolute( - dy * (Math.random() * (coeff3max - coeff3min) + coeff3min)));
              s8 = s6.perpendicularEnd(concav);
              s8 = new Segment(s8.p1, s8.pointOnAbsolute(dx * (Math.random() * (coeff4max - coeff4min) + coeff4min)));
              s9 = s7.perpendicularEnd(!concav);
              s9 = new Segment(s9.p1, s9.pointOnAbsolute(dx * (Math.random() * (coeff4max - coeff4min) + coeff4min)));

              brd.points[0] = s1.p1.copy();
              brd.points[1] = s1.p2.copy();
              brd.points[2] = s3.p2.copy();
              brd.points[3] = s6.p2.copy();
              brd.points[4] = s8.p2.copy();
              brd.points[5] = s9.p2.copy();
              brd.points[6] = s7.p2.copy();
              brd.points[7] = s4.p2.copy();
              brd.points[8] = s2.p2.copy();
              brd.points[9] = s2.p1.copy();
              // duplicate as left side of right cell
              this.pieces[ky][kx + 1].ls = brd;
            } // end of right side

          } // for kx
        } // for ky

        this.associateImage();

      } // function next

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// called when picture is loaded

      Puzzle.prototype.associateImage = function() {
        let kx, ky, kn, kp;
        let div, scale, he, wi, offsx, offsy, pc;

        // scale picture
        wi = this.image.width;
        he = this.image.height;

        if (wi / he > this.width / this.height) { // actual picture "more horizontal" than board
          scale = this.height / he;
          offsy = 0;
          offsx = (wi - this.width / scale) / 2; // offset in source picture
        } else { // actual picture "more (or equally)horizontal" than board
          scale = this.width / wi;
          offsx = 0;
          offsy = (he - this.height / scale) / 2; // offset in source picture
        }


        this.mech =  { scale: scale, offsx: offsx, offsy: offsy }; // informations for scaling

// creation of pieces
// table of PolyPieces
        this.polyPieces = [];


        for (ky = 0; ky < this.ny; ky++) {
          for (kx = 0; kx < this.nx; kx++) {
            this.pieces[ky][kx].createDivPiece(this, scale, offsx, offsy);
            this.polyPieces.push(new PolyPiece(this.pieces[ky][kx], this));
          } // for kx
        } // for ky

// random zindex for initial pieces
        arrayShuffle(this.polyPieces);
        this.evaluateZIndex();

        for (kp = 0; kp < this.polyPieces.length; kp++) {
          for (kn = 0; kn < this.polyPieces[kp].pieces.length; kn++) {
            pc = this.polyPieces[kp].pieces[kn];

            this.divBoard.appendChild(pc.theDiv);
            switch(this.freeSpace){
              case 0 : pc.pTarget = new Point((this.reqWidth - (2.25 + Math.random() / 4) * this.dx) * 1/mycoeff, Math.random() * (this.height -  this.dy) - this.dy);break; //здесь указываем чтобы элементы паззла в начале игры ушли подальше в правую сторону ПОМЕТКА
              case 1 : pc.pTarget = new Point((Math.random() * (this.width -  this.dx) - this.dx) * 1/mycoeff, this.reqHeight - (2.25 + Math.random() / 4) * this.dy); //здесь указываем чтобы элементы паззла в начале игры ушли подальше в правую сторону ПОМЕТКА
            } // switch
          } // for kn
        } // for kp
        window.setTimeout((function(obj) {return function() {obj.launchAnimation()}})(this), 1000);

      } // Puzzle.prototype.associateImage

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.addRemovableEventListener = function(event, funct) {

        this.divBoard.addEventListener(event, funct);
        this.listeners.push({event: event, funct: funct});
      } // Puzzle.prototype.addRemovableEventListener
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      Puzzle.prototype.remove1Listener = function() {
        if (this.listeners.length == 0 ) return; // ràf
        let a = this.listeners.pop();
        this.divBoard.removeEventListener(a.event, a.funct);
      } // Puzzle.prototype.remove1Listener
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      Puzzle.prototype.removeAllListeners = function() {
        let a;
        while (this.listeners.length > 0 ) {
          a = this.listeners.pop();
          this.divBoard.removeEventListener(a.event, a.funct);
        } // while
      } // Puzzle.prototype.removeAllListeners()
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.launchAnimation = function() {

        this.anim = {cpt: autoStart ? 200 : 100 };
        this.anim.tmr = window.setInterval((function(puzz){return function(){puzz.animate()}})(this), 20);

      } // launchAnimation
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.animate = function() {
        let kp, kn, pc, act, cib;

        if (this.anim.cpt == 0){
          window.clearInterval(this.anim.tmr);
          delete this.anim;

          this.evaluateZIndex();
          this.beginGame();

          return;
        }
        this.anim.cpt--;
        for (kp = 0; kp < this.polyPieces.length; kp++) {
          for (kn = 0; kn < this.polyPieces[kp].pieces.length; kn++) {
            pc = this.polyPieces[kp].pieces[kn];
            act = pc.where();
            cib = pc.pTarget;
            pc.moveTo(new Point((this.anim.cpt * act.x + cib.x) / (this.anim.cpt + 1), (this.anim.cpt * act.y + cib.y) / (this.anim.cpt + 1)));
            if (this.anim.cpt == 0) { delete pc.pTarget ; }
          } // for kn
        } // for kp
      } // Puzzle.prototype.animate

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// almost the same as 'animate, mais only to center the picture when game is over

      Puzzle.prototype.animateEnd = function() {
        console.log('over')
        let xcou, ycou;

        if (this.anim.cpt == 0){
          window.clearInterval(this.anim.tmr);
          delete this.anim;
          return;
        }
        this.anim.cpt--;
        xcou = parseFloat(this.canvMobile.style.left);
        ycou = parseFloat(this.canvMobile.style.top);

        this.canvMobile.style.left = (this.anim.cpt * xcou + this.anim.xfin) / (this.anim.cpt + 1) + "px";
        this.canvMobile.style.top = (this.anim.cpt * ycou + this.anim.yfin) / (this.anim.cpt + 1) + "px";

      } // Puzzle.prototype.animateEnd


// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// merges polyPieces[n2] and polyPieces[n1] into a new piece
// removes those pieces and inserts nes one
// re evaluates z-orders accordingly
// return index of new polyPiece

      Puzzle.prototype.merge = function(n1, n2) {

        let nppiece, nbpieces, k;
        this.polyPieces[n1].merge(this.polyPieces[n2]); // merges pieces
        nppiece = this.polyPieces[n1]; // save new piece
        if (n1 > n2) {
          this.polyPieces.splice(n1, 1);
          this.polyPieces.splice(n2, 1);
        } else {
          this.polyPieces.splice(n2, 1);
          this.polyPieces.splice(n1, 1);
        }

// will insert nes PolyPiece immediately before the first with less pieces
        nbpieces = nppiece.pieces.length;
        for (k = 0; k < this.polyPieces.length && this.polyPieces[k].pieces.length >= nbpieces; k++) {;}
        // insert new
        this.polyPieces.splice(k, 0, nppiece);

        return k;
      } // puzzle.prototype.merge

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.evaluateZIndex = function() {

        let kp, kn, z;
        z = 1;
        for (kp = 0; kp < this.polyPieces.length; kp++) {
          for (kn = 0; kn < this.polyPieces[kp].pieces.length; kn++) {
            this.polyPieces[kp].pieces[kn].theDiv.style.zIndex = z++;
          } // for kn
        } // for kp

      } // Puzzle.prototype.evaluateZIndex

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// beginning of game
      Puzzle.prototype.beginGame = function() {
        let that_local = this
        console.log('begin')
        function checkTimer(){
          if (totalAmount <= 0){
            that_local.removeAllListeners();
            that_local.endGame();
          }
        }
        function checkGameStop(){
          console.log(that.is_game_stop)
          if (that.is_game_stop){
            that_local.removeAllListeners();
            that_local.endGame();
          }
        }
        timeSet();
        checkGameStopInterval = setInterval(checkGameStop, 1000);
        checkTimerInterval = setInterval(checkTimer, 1000);

// record offset between mouse coordinates et board origin

        let styl = getComputedStyle(this.divGame);

        // let left_menu = document.getElementById('left_menu')
        // console.log(left_menu.getBoundingClientRect().width)



        if (that.$q.screen.gt.md){
          this.mouseOffsY = this.divGame.offsetTop + parseFloat(styl.borderTopWidth);
          this.mouseOffsX = this.divGame.offsetLeft + parseFloat(styl.borderLeftWidth) + 400 //+ left_menu.getBoundingClientRect().width;
        }else {
          this.mouseOffsX = this.divGame.offsetLeft + parseFloat(styl.borderLeftWidth)  //+ left_menu.getBoundingClientRect().width;
          this.mouseOffsY = this.divGame.offsetTop + parseFloat(styl.borderTopWidth) - 100;
        }
        this.mouseOffsY = this.divGame.offsetTop + parseFloat(styl.borderTopWidth);
        this.pieceMove = false; // no selected piece
// set event listeners

        this.addRemovableEventListener("mousedown", (function(puzzle){
          return function(event) {
            puzzle.mouseDownGame(event);}})(this));

        this.addRemovableEventListener("touchstart", (function(puzzle){
          return function(event) {
            puzzle.touchDownGame(event);}})(this));


        this.addRemovableEventListener("mouseup", (function(puzzle){
          return function(event) {
            puzzle.mouseUpGame(event);}})(this));
        this.addRemovableEventListener("touchend", (function(puzzle){
          return function(event) {
            puzzle.mouseUpGame(event);}})(this));


        this.addRemovableEventListener("mousemove", (function(puzzle){
          return function(event) {
            puzzle.mouseMoveGame(event);}})(this));
        this.addRemovableEventListener("touchmove", (function(puzzle){
          return function(event) {
            puzzle.touchMoveGame(event);}})(this));

      } // Puzzle.prototype.beginGame

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

      Puzzle.prototype.endGame = function() {
        console.log('endgame')
        document.getElementById('forPuzzle').innerHTML=''
        totalAmount = 0
        clearInterval(checkTimerInterval);
        clearInterval(checkGameStopInterval);
        that.looseGame()
      } // Puzzle.prototype.endGame


// mouseDown during game
      Puzzle.prototype.mouseDownGame = function(event) {
        console.log('mouse down')

        this.pieceMove = this.lookForPiece(event,false) ;
        if (this.pieceMove === false) return;
        this.emphasize(this.pieceMove.pp);
// we will add to the 'this.pieceMove' object the offset between mousePosition and
//   canvMobile position for proper movement of canvMobile when mose moves

        this.pieceMove.offsx =  event.pageX - this.mouseOffsX  - parseFloat(this.canvMobile.style.left);
        this.pieceMove.offsy =  event.pageY - this.mouseOffsY - parseFloat(this.canvMobile.style.top);
        this.divGame.style.cursor = 'move';

      } // Puzzle.prototype.mouseDownGame
      Puzzle.prototype.touchDownGame = function(event) {

        let touch = event.changedTouches ? event.changedTouches[0] : false;
        let pageX =  touch.pageX;
        let pageY = touch.pageY;
        console.log('touchDownGame',touch)

        this.pieceMove = this.lookForPiece(event,true) ;
        console.log(this.pieceMove)
        if (this.pieceMove === false) return;
        this.emphasize(this.pieceMove.pp);
// we will add to the 'this.pieceMove' object the offset between mousePosition and
//   canvMobile position for proper movement of canvMobile when mose moves
        console.log(this.canvMobile)
        this.pieceMove.offsx =  pageX -  parseFloat(this.canvMobile.style.left);
        this.pieceMove.offsy =  pageY -  parseFloat(this.canvMobile.style.top);
        this.divGame.style.cursor = 'move';

      } // Puzzle.prototype.mouseDownGame
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

// mouseUp during game
      Puzzle.prototype.mouseUpGame = function(event) {

        let k, polyP, pc;

        this.divGame.style.cursor = 'default';

        if (this.pieceMove === false) return;
        console.log(this.pieceMove)
// hide the canvasMobile which was used for the moving piece
        let canvx = parseFloat(this.canvMobile.style.left);
        let canvy = parseFloat(this.canvMobile.style.top);
        this.canvMobile.getContext("2d").clearRect(0, 0, this.canvMobile.width, this.canvMobile.height);

// display again original pieces
        polyP = this.polyPieces[this.pieceMove.pp];
        for (k = 0; k < polyP.pieces.length; k++) {
          pc = polyP.pieces[k]
          pc.moveTo (new Point( this.dx * (pc.kx - 1) + canvx, this.dy * (pc.ky - 1) + canvy));
          pc.theDiv.style.visibility = 'visible';
        } // for k

// check if moved piece is close enough of another to merge them
//  check again with the result of the merge operation

        let idp = this.pieceMove.pp;
        let yesMerge = false, yesyesMerge = false;
        do {
          yesMerge = false;
          polyP = this.polyPieces[idp];
          for (k = 0; k < this.polyPieces.length; k++) {
            if (k ===  idp) continue; // don't check neighborhood with itself !
            if (polyP.ifNear(this.polyPieces[k])) { // yes !
              idp = this.merge(k, idp); // merge and keep track of index of merged piece
              yesMerge = true; yesyesMerge = true; // il y a fusion de 2 pièces
              break; // out of  'for' loop
            } // if we found a piece
          } // for
        } while (yesMerge) ; // do it again if pieces werge merged

// if no merging, move (if this.polypieces) the selected PolyPiece before
// those with the same number of pieces

        if (! yesyesMerge) {
          let tmp = this.polyPieces[idp]; // memorize polyPiece
          this.polyPieces.splice(idp, 1); // remove from list
          for (k = idp; (k < this.polyPieces.length) && (this.polyPieces[k].pieces.length >= tmp.pieces.length); k++) ;
          this.polyPieces.splice(k, 0, tmp); // re-insert at the right place
        } // if no merging

        this.evaluateZIndex();
        this.pieceMove = false;

// won ?
        if (this.polyPieces.length>1) return; // no, continue

// YES ! tell the player
        this.removeAllListeners();
        console.log('COMPLETE')
        totalAmount = 0
        document.getElementById('forPuzzle').innerHTML=''
        clearInterval(checkTimerInterval);
        clearInterval(checkGameStopInterval);

        that.winGame()
// normal image id re-drawn
        let ctx = this.canvMobile.getContext("2d");
        ctx.drawImage(this.image,
          this.mech.offsx, this.mech.offsy,
          this.width / this.mech.scale, this.height / this.mech.scale,
          0, 0,
          this.width, this.height);
        this.anim = {cpt: 100, xorg: 0, yorg: 0, xfin: (this.reqWidth - this.dx * this.nx) / 2,
          yfin: (this.reqHeight - this.dy * this.ny) / 2};

        this.anim.xorg = parseFloat(this.polyPieces[0].pieces[0].theDiv.style.left) + this.dx;
        this.anim.yorg = parseFloat(this.polyPieces[0].pieces[0].theDiv.style.top) + this.dy
        this.canvMobile.style.left = this.anim.xorg + "px";
        this.canvMobile.style.top = this.anim.yorg + "px";

// hide pieces
        for (k = 0; k < this.polyPieces[0].pieces.length; k++) {
          this.polyPieces[0].pieces[k].theDiv.style.visibility = "hidden";
        } // for k

// launch final animation

        let dist = Math.sqrt(
          (this.anim.xorg - this.anim.xfin) * (this.anim.xorg - this.anim.xfin) +
          (this.anim.yorg - this.anim.yfin) * (this.anim.yorg - this.anim.yfin));
// we want a speed of about 100 pix / s
// the time increment beeing of 20 ms, this leads to 100 * 0.02 = 2 pix / pass
        this.anim.cpt = dist / 2;
// limit the duration to the range 0.25..2s, i.e.12..100 steps
        if (this.anim.cpt < 12) this.anim.cpt = 12;
        if (this.anim.cpt > 100) this.anim.cpt = 100;
        this.anim.cpt = Math.floor(this.anim.cpt);
        this.anim.tmr = window.setInterval((function(puzz){return function(){puzz.animateEnd()}})(this), 20);

      } // Puzzle.prototype.mouseUpGame
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      Puzzle.prototype.stopGame = function(){
        this.removeAllListeners();
        this.anim.tmr = window.setInterval((function(puzz){return function(){puzz.animateEnd()}})(this), 20);
      }
// mouseMove during game
      Puzzle.prototype.mouseMoveGame = function(event) {

        if (this.pieceMove === false) return;

// for the case where button was released out of 'good' area

        if ((event.buttons & 1) == 0) { this.mouseUpGame(event); return; }

        let x =  event.pageX - this.mouseOffsX;
        let y =  event.pageY - this.mouseOffsY;

        if (x < 2) x = 2;
        if (x > Math.floor(parseFloat(this.divBoard.style.width)) - 2) x  = Math.floor(parseFloat(this.divBoard.style.width)) - 2;
        if (y < 2) y = 2;
        if (y > Math.floor(parseFloat(this.divBoard.style.height)) - 2) y  = Math.floor(parseFloat(this.divBoard.style.height)) - 2;

        this.canvMobile.style.left = (x - this.pieceMove.offsx) + "px";
        this.canvMobile.style.top = (y - this.pieceMove.offsy) + "px";

      } // Puzzle.prototype.mouseMoveGame

      Puzzle.prototype.touchMoveGame = function(event) {
        console.log('touchMoveGame')

        if (this.pieceMove === false) return;

// for the case where button was released out of 'good' area

        //if ((event.buttons & 1) == 0) { this.mouseUpGame(event); return; }
        var touch = event.changedTouches[0];

        let x =  touch.pageX - this.mouseOffsX;
        let y =  touch.pageY - this.mouseOffsY;

        if (x < 2) x = 2;
        if (x > Math.floor(parseFloat(this.divBoard.style.width)) - 2) x  = Math.floor(parseFloat(this.divBoard.style.width)) - 2;
        if (y < 64) y = 64;
        console.log(Math.floor(parseFloat(this.divBoard.style.height)) - 2)
        console.log('y',y)
        if (y > Math.floor(parseFloat(this.divBoard.style.height)) - 2)
        {

          y  = Math.floor(parseFloat(this.divBoard.style.height)) - 2;
        }


        this.canvMobile.style.left = (x - this.pieceMove.offsx) + "px";
        this.canvMobile.style.top = (y - this.pieceMove.offsy) + "px";

      } // Puzzle.prototype.mouseMoveGame

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// searches the pieces whick was clicked on
// event is the click event
// returned value : (index of PolyPiece + piece) or false (if not on a piece)

      Puzzle.prototype.lookForPiece = function(event,is_touch) {

        let pageX
        let pageY

        if(is_touch){
          console.log('touch event')
          let touch = event.changedTouches ? event.changedTouches[0] : false;
          pageX =  touch.clientX;
          pageY = touch.clientY-120;
        }else {
          console.log('mouse event')
          pageX =  event.pageX;
          pageY = event.pageY-120
        }
        let kp, kn, z;

        let x = pageX - this.mouseOffsX;
        let y =  pageY - this.mouseOffsY;
        for (kp = this.polyPieces.length - 1; kp >= 0; kp--) {
          for (kn = this.polyPieces[kp].pieces.length - 1; kn >= 0; kn--) {
            if (this.polyPieces[kp].pieces[kn].insidePiece(x, y)) return {pp: kp, pc: kn};
          } // for kn
        } // for kp

        return false; // found nothing
      } // Puzzle.prototype.lookForPiece

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
// emphasizes a polyPiece
// its idividualpieces are masked (style.visibility = "hidden")
// but they are collectively drawn on canvMobile
// parameter : polyPiece index

      Puzzle.prototype.emphasize = function(npp) {

        let kbcl, kc, k;
        let ppc = this.polyPieces[npp]; // current PolyPiece
        let ctx = this.canvMobile.getContext("2d");
        let loops = lookForLoops(ppc.pieces);
        let edge;

        ctx.save();
        ctx.clearRect(0, 0, this.canvMobile.width, this.canvMobile.height);
        ctx.beginPath();
        for (kbcl = 0;kbcl < loops.length; kbcl++) {
          for (kc = 0; kc < loops[kbcl].length; kc++) {
            edge = loops[kbcl][kc];

            switch (edge.edge) {
              case 0 : ppc.pieces[edge.kp].ts.drawPath(ctx, 0, 0, false, (kc!= 0)); break;
              case 1 : ppc.pieces[edge.kp].rs.drawPath(ctx, 0, 0, false, (kc!= 0)); break;
              case 2 : ppc.pieces[edge.kp].bs.drawPath(ctx, 0, 0, true, (kc!= 0)); break;
              case 3 : ppc.pieces[edge.kp].ls.drawPath(ctx, 0, 0, true, (kc!= 0)); break;
            }
          } // for kc
        } // for kbcl;

// make shadow
        ctx.fillStyle = 'none';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 4;
        ctx.shadowOffsetY = 4;
        ctx.fill();

// add image clipped by path
        ctx.clip('evenodd');

        ctx.drawImage(this.image,
          this.mech.offsx, this.mech.offsy,
          this.width / this.mech.scale, this.height / this.mech.scale,
          0, 0,
          this.width, this.height);

// hide original PolyPiece
        for (k = 0; k < ppc.pieces.length; k++) {
          ppc.pieces[k].theDiv.style.visibility = "hidden";
        } // for k

        ctx.restore();

// set picture position to hide previous one
        this.canvMobile.style.left = (ppc.pieces[0].where().x - (ppc.pieces[0].kx - 1) * this.dx) + "px";
        this.canvMobile.style.top = (ppc.pieces[0].where().y - (ppc.pieces[0].ky - 1) * this.dy) + "px";
        this.canvMobile.style.visibility = 'visible';

      } // emphasize

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -

// checks if p1 and p2 pieces are close to each other
// dx is -1, 0 or 1 to check left, (top or bottom) or right side of p1
// dy is -1, 0 or 1 to check top, (left or right) or bottom of p2

      Puzzle.prototype.near  = function (p1, p2, dx, dy) {
        let ou1 = p1.where();
        let ou2 = p2.where();

        if (Math.abs (ou1.x - ou2.x + dx * this.dx) > this.dCoupling) return false;
        if (Math.abs (ou1.y - ou2.y + dy * this.dy) > this.dCoupling) return false;
        return true;
      } // near

// fin class puzzle

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   -
      /* computes the number of lines and columns of the puzzle,
        finding the best compromise between the requested number of pieces
        and a square shap for pieces
      */

      Puzzle.prototype.computenxAndny = function() {

        let kx, ky, width = this.image.width, height = this.image.height, npieces = this.npieces;
        let err, err2, errmin = 1e9;
        let ncv, nch;

        let nHPieces = Math.round(Math.sqrt(npieces * width / height));
        let nVPieces = Math.round(npieces / nHPieces);


        /* based on the above estimation, we will try up to + / - 2 values
           and evaluate (arbitrary) quality criterion to keep best result
        */

        for (ky = 0;ky < 5;ky++) {
          ncv = nVPieces + ky - 2;
          for (kx = 0;kx < 5;kx++) {
            nch = nHPieces + kx - 2;
            err = nch * height / ncv / width;
            err = (err + 1 / err) - 2; // error on pieces dimensions rationmesure erreur sur proportions des pièces (par rapport à un carré)
            err += Math.abs(1 - nch * ncv / npieces); // adds error on number of pieces

            if (err < errmin) { // keep smallest error
              errmin = err;
              this.nx = nch;
              this.ny = ncv;
            }
          } // for kx
        } // for ky

      } // computenxAndny

//---------------------------------------------------------------------------- -
//---------------------------------------------------------------------------- -

      /* algorithm to determine the boundary of a PolyPiece
        input : a table of cells, hopefully defining a 'good' PolyPiece, i.e. all connected together
        every cell is given as an object {kx: indice, ky: indice} representing an element of a 2D array.

        returned value : table of Loops, because the boundary may be made of several
      simple loops : there may be a 'hole' in a PolyPiece
      every loop is a list of consecutive edges,
      every edge if an object {kp: index, edge: b} where kp is the index of the cell ine
      the input array, and edge the side (0(top), 1(right), 2(bottom), 3(left))
      every edge contains kx and ky too, normally not used here
      */

      function lookForLoops (tbCases) {

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
// internal : checks if an edge given by kx, ky is common with another cell
// returns true or false

        function edgeIsCommon (kx, ky, edge) {
          let k;
          switch(edge) {
            case 0 : ky--; break; // top edge
            case 1 : kx++; break; // right edge
            case 2 : ky++; break; // bottom edge
            case 3 : kx--; break; // left edge
          } // switch
          for (k = 0; k < tbCases.length;k++) {
            if (kx == tbCases[k].kx && ky == tbCases[k].ky) return true; // we found the neighbor
          }
          return false; // not a common edge
        } // function edgeIsCommon

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
// internal : checks if an edge given by kx, ky is in tbEdges
// return index in tbEdges, or false

        function edgeIsInTbEdges (kx, ky, edge) {
          let k;
          for (k = 0; k < tbEdges.length;k++) {
            if (kx == tbEdges[k].kx && ky == tbEdges[k].ky && edge == tbEdges[k].edge) return k; // found it
          }
          return false; // not found
        } // function edgeIsInTbEdges

// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

        let tbLoops = []; // for the result
        let tbEdges = []; // set of edges which are not shared by 2 pieces of input
        let k;
        let kEdge; // pour count 4 edges
        let lp; // for loop during its creation
        let currEdge; // current edge
        let tries; // tries counter
        let edgeNumber; // number of edge found during research
        let potNext;

// table of tries
// used to determine what is the next edge to try when walking around a loop
// contient 1 élément par edge, en fonction du edge sur lequel on se trouve
//  chaque élément contient 3 tentatives à essayer dans l'ordre pour toujours tourner dans le même sens
//  chaque tentative contient le dkx et le dky pour indiquer la position du voisin concerné
//   et un edge pour dire quel est le prochain edge
// (avec ce tableau, les bords sont parcourus dans le sens où le programme les dessine)

        let tbTentatives = [
          // if we are on edge 0 (top)
          [
            {dkx: 0, dky: 0, edge: 1}, // try # 0
            {dkx: 1, dky: 0, edge: 0}, // try # 1
            {dkx: 1, dky: -1, edge: 3} // try # 2
          ],
          // if we are on edge 1 (right)
          [
            {dkx: 0, dky: 0, edge: 2},
            {dkx: 0, dky: 1, edge: 1},
            {dkx: 1, dky: 1, edge: 0}
          ],
          // if we are on edge 2 (bottom)
          [
            {dkx: 0, dky: 0, edge: 3},
            {dkx: - 1, dky: 0, edge: 2},
            {dkx: - 1, dky: 1, edge: 1}
          ],
          // if we are on edge 3 (left)
          [
            {dkx: 0, dky: 0, edge: 0},
            {dkx: 0, dky: - 1, edge: 3},
            {dkx: - 1, dky: - 1, edge: 2}
          ],
        ];


// create list of not shared edges (=> belong to boundary)
        for (k = 0;k < tbCases.length;k++) {
          for (kEdge = 0; kEdge < 4; kEdge++) {
            if (!edgeIsCommon(tbCases[k].kx, tbCases[k].ky, kEdge))
              tbEdges.push({kx: tbCases[k].kx, ky: tbCases[k].ky, edge: kEdge, kp: k})
          } // for kEdge
        } // for k

        while (tbEdges.length > 0) {
          lp = []; // new loop
          currEdge = tbEdges[0];   // we begin with first available edge
          lp.push(currEdge);       // add it to loop
          tbEdges.splice(0, 1);    // remove from list of available sides
          do {
            for (tries = 0; tries < 3;tries++) {
              potNext = tbTentatives[currEdge.edge][tries];
              edgeNumber = edgeIsInTbEdges(currEdge.kx + potNext.dkx, currEdge.ky + potNext.dky, potNext.edge);
              if (edgeNumber === false) continue; // can't here
              // new element in loop
              currEdge = tbEdges[edgeNumber];     // new current edge
              lp.push(currEdge);              // add it to loop
              tbEdges.splice(edgeNumber, 1);  // remove from list of available sides
              break; // stop tries !
            } // for tries
            if (edgeNumber === false) break; // loop is closed
          } while (1); // do-while exited by break
          tbLoops.push(lp); // add this loop to loops list
        } // while tbEdges...
        return tbLoops;
      } // function lookForLoops

//---------------------------------------------------------------------------- -





      let x = new Puzzle ( {img: image,
        width: document.getElementById('puzzle_wrapper').clientWidth ,
        height: document.getElementById('puzzle_wrapper').clientHeight,
        idiv: "forPuzzle" });



    }
  }

}
</script>
<style lang="sass">
.adModal
  background: #DCF34E
.q-tooltip
  background: rgba(0, 0, 0, 0.5)
  border-radius: 10px
  padding: 20px
.tooltip
  & .q-btn__wrapper
    padding: 0
  & .q-focus-helper
    border-radius: 9px !important
//slider
.slider-area
  position: relative
  border-radius: 20px
  height: 700px

.slider-container
  position: absolute
  top:  50%
  left: 50%
  transform: translate(-50%, -50%)

  width: 90%
  height: calc(90% - 60px)
  margin: 0px
  padding: 0px
  z-index: 1
  background-color: #DDD
  max-width: 600px
  max-height: 600px

.puzzle-board:focus
  outline: none

//slider
.timer
  background: #DCF34E
  display: flex
  align-items: center
  padding: 5px 15px
#timer

  color: #0F1549
  font-family: 'Miratrix', sans-serif
  letter-spacing: 0.04em
.game-grid
  display: grid
  grid-gap: 30px
  grid-template-columns: repeat(3,1fr)
.game-type
  background: #352072
  transition: all .2s linear
  padding: 30px 30px
  text-align: center
  img
    width: 100px
    height: 100px
    object-fit: contain
    margin-bottom: 20px
  &:hover
    background: #DCF34E
    & .game-type__name
      color: #0F1549
    & .game-type__price
      color: #0F1549
  &__name
    color: #ffffff
    font-size: 16px
    transition: all .2s linear
  &__price
    transition: all .2s linear
    font-size: 16px
    color: #DCF34E
.game-level
  height: 160px
  width: 160px
  transition: all .2s linear
  background-size: contain !important
  &:hover
    transform: scale(1.05)

#puzzle_wrapper
  height: 90vh
  overflow-y: hidden

#forPuzzle
  border: none
  left: 0
  top: 0

@media (max-width: 599px)
  .game-type
    height: 150px
    width: 150px
    margin-bottom: 15px
//.game-level
//  height: 80px
//  width: 80px

</style>
